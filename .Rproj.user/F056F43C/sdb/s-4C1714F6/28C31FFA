{
    "contents" : "---\ntitle: \"Common Data Manipulations in R\"\nauthor: \"Andrew MacDonald\"\ndate: '2014-11-07'\noutput: \n    html_document:\n      keep_md: TRUE\n---\n\n# Simple data manipulations in R\n\nMany years ago, I was introduced to R by [Cam Webb ](http://camwebb.info/).  At the time, his website contained a list of common data manipulations (original [here](http://camwebb.info/blog/2014-04-29/)).  This list dated from Cam's early experience with R, and contained the R-help mailing list responses to a series of data manipulations.  For a long time, I kept this file as a handy reference.  I printed it out.  I recommended it to friends.\n\nNow I have been using R for years, and the state of the art has advanced considerably.  Particulary, [Hadley Wickham's](https://github.com/hadley) `reshape2` and `dplyr` packages have transformed the way most useRs manipulate their data.  I decided that it would be interesting to revisit my favourite resource and try my hand at solving these problems with tools from these two packages.\n\n\n```{r message=FALSE}\nlibrary(reshape2)\nlibrary(dplyr)\nlibrary(knitr)\n```\n\n\n\n\n\n## GROUP\n\nTurn this table (A):\n\n\n| c1 | c2 | c3 |\n|----|----|----|\n| A  | a  |  1 |\n| A  | a  |  3 |\n| A  | a  |  1 |\n| A  | b  |  1 |\n| A  | b  |  2 |\n| B  | c  |  2 |\n| B  | d  |  1 |\n\n\ninto this (B):\n\n| Group1 | Group2 | Nrows | SumOfCol3 |\n|--------|--------|-------|-----------|\n| A      | a      |     3 |         5 |\n| A      | b      |     2 |         3 |\n| B      | c      |     1 |         2 |\n| B      | d      |     1 |         1 |\n\n\n\n```{r results='asis'}\nA <- data.frame(\n       c1 = c('A', 'A', 'A', 'A', 'A', 'B', 'B'),\n       c2 = c('a', 'a', 'a', 'b', 'b', 'c', 'd'),\n       c3 = c(1, 3, 1, 1, 2, 2, 1))\n\nB <- A %>%\n  group_by(c1,c2) %>%\n  summarize(Nrows=n(),\n            SumOfCol3=sum(c3))\nB %>%\n\tungroup %>%\n\tkable\n```\n\n\n## SPLIT\n\nTurn col3 of the second table (B) into this (C):\n\n| row | a | b | c | d |\n|-----|---|---|---|---|\n| A   | 3 | 2 | . | . |\n| B   | . | . | 1 | 1 |\n\n\n```{r results='asis'}\nC <- dcast(B,c1~c2,value.var=\"Nrows\")\nkable(C)\n```\n\n\nMany original responders suggested the use of `table`, referring to the original dataset:\n\n\n```{r results='asis'}\nC_alt<-with(A,table(c1,c2))\nkable(C_alt)\n```\n\n\nalthough that solution is not [\"tidy\" in the Hadlian sense](http://vita.had.co.nz/papers/tidy-data.pdf) -- i.e., it does not return a `data.frame`, but rather a `table` object.  You can obtain a data.frame with `dcast` directly:\n\n\n```{r results='asis'}\nC_alt2<-dcast(A,c1~c2,value.var=\"c3\",fun.aggregate=length)\nkable(C_alt2)\n```\n\n\n\n## STACK\n\nTurn the above table (C) into this (D):\n\n| c1 | V1 | V2 |\n|----|----|----|\n| A  | a  | 3  |\n| A  | b  | 2  |\n| A  | c  | .  |\n| A  | d  | .  |\n| B  | a  | .  |\n| B  | b  | .  |\n| B  | c  | 1  |\n| B  | d  | 1  |\n\n\n```{r results='asis'}\nD <- melt(C,id=\"c1\") %>%\n  arrange(c1)\nkable(D)\n```\n\n\n## JOIN\n\nJoin these tables (E, F):\n\n| c1 | c2 |\n|----|----|\n| A  |  1 |\n| B  |  2 |\n| C  |  3 |\n\n| c1 | c3 |\n|----|----|\n| A  | a  |\n| B  | a  |\n| B  | a  |\n| B  | b  |\n| C  | c  |\n| A  | b  |\n\nto give (G):\n\n| c1 | c3 | c2 |\n|----|----|----|\n| A  | a  |  1 |\n| B  | a  |  2 |\n| B  | a  |  2 |\n| B  | b  |  2 |\n| C  | c  |  3 |\n| A  | b  |  1 |\n\n\n```{r results='asis'}\nE<-data.frame(c1=c(\"A\",\"B\",\"C\"), c2=1:3)\nFF <- data.frame(c1=c(\"A\",\"B\",\"B\",\"B\",\"C\",\"A\"), c3=c(\"a\",\"a\",\"a\",\"b\",\"c\",\"b\"))\nG <- left_join(FF, E)\nkable(G)\n```\n\nthe `dplyr` package supplies `left_join()`, which preserves the sequence of rows in its left argument.  Alternative, as was originally suggested, one could use `merge()` :\n\n\n```{r results='asis'}\nG_merge <- merge(FF,E)\nkable(G_merge)\n```\n\nAlthough columns now come out sorted.\n\n## SUBSET \n\nsubset Table G to give H:\n\n| c1 | c3 | c2 |\n|----|----|----|\n| A  | a  |  1 |\n| A  | b  |  1 |\n\n\n\n```{r results='asis'}\nH <- filter(G,c1==\"A\")\nkable(H)\n```\n\n## TRANSPOSE\n\ntranspose H to give:\n\n| V1 | V2 |\n|----|----|\n| A  | A  |\n| a  | b  |\n| 1  | 1  |\n\n\n```{r results='asis'}\nH_transpose <- data.frame(t(H))\nkable(H_transpose)\n```\n\n\n## SORT\n\nIn the original, the question suggested \"up to three keys\".\n\n\n```{r results='asis'}\nA_arranged <- arrange(A,c1,c2,c3)\nkable(A_arranged)\n```\n\n\n## Conclusion\n\nTo my surprise, each of these was actually a single line.  The only exception was the first (GROUP), and that was because there are really two separate steps here -- the first to actually group the data, the second to apply summary functions to the data.  `dplyr` automates both tasks, and supplies great readability.  ",
    "created" : 1415406124859.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3793173555",
    "id" : "28C31FFA",
    "lastKnownWriteTime" : 1415406763,
    "path" : "~/Documents/projects/data_manipulation/data_manipulations.Rmd",
    "project_path" : "data_manipulations.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_markdown"
}